# -*- coding: utf-8 -*-
"""HW6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HNwA9jHEUfXzWtmDyKXHYa-1o7KyLW9p
"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

img = Image.open('Dan Bricklin.jpeg')
img_array = np.array(img)/255
plt.figure(figsize=(9, 6))
plt.imshow(img)

U_red, S_red, V_red = np.linalg.svd(img_array[:, :, 0], full_matrices=False)
U_green, S_green, V_green = np.linalg.svd(img_array[:, :, 1], full_matrices=False)
U_blue, S_blue, V_blue = np.linalg.svd(img_array[:, :, 2], full_matrices=False)

def get_k_singular_graph(k=10):
    restore = []
    restore.append(U_red[:, :k] * S_red[:k] @ V_red[:k, :])
    restore.append(U_green[:, :k] * S_green[:k] @ V_green[:k, :])
    restore.append(U_blue[:, :k] * S_blue[:k] @ V_blue[:k, :])
    restore = np.array(restore)
    return np.moveaxis(restore, 0, 2)

def normalize(a):
    return (a - a.min()) / (a.max() - a.min())

"""# Q1"""

k_list = [1, 5, 50, 150, 400, 1050, 1289]
approximation_error = []
for i, k in enumerate(k_list):
    plt.figure()
    plt.imshow(normalize(get_k_singular_graph(k)))
    approximation_error.append(np.linalg.norm(img_array - normalize(get_k_singular_graph(k))))
plt.figure(figsize=(9,6))
plt.plot(k_list, approximation_error)
plt.xlabel('k')
plt.ylabel('norm error')
plt.title('approximation_error')

"""# Q2

The length of singular value on the R channel equalis to the rank of the matrix,
"""

rank = S_red
print(rank[:100])

"""# Q3"""

A = []
for i in range(5):
    A.append(U_red[:, i:i+1] * S_red[i] @ V_red[i:i+1, :])
    plt.figure()
    plt.imshow(A[i], cmap='gray')
plt.figure()
plt.imshow(np.array(A).sum(axis=0), cmap='gray')